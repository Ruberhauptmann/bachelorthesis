\documentclass[main.tex]{subfiles}

\begin{document}
\chapter{Physical and Computational Basics\label{chap:theory}}
%\epigraph{It's a secret to everybody.}{a Moblin in \textit{The Legend of Zelda}}

\section{The electronic structure problem\label{sec:theory_schrödinger}}

In solid state physics, one general problem we are concerned with is finding the properties of the ground state of an isolated system of \(N\) interacting electrons in an external potential.
The system is described by the Schrödinger equation
\begin{equation}
    \ope{H} \Psi (\vb{r}_1, \ldots, \vb{r}_N) = E \Psi (\vb{r}_1, \ldots, \vb{r}_N)
\end{equation}
with the Hamiltonian
\begin{align}
    \ope{H} &= \ope{T}_e + \ope{V}_{n-e} + \ope{V}_{e-e} + \ope{V}_{n-n} \\
    &= -\sum_i \frac{1}{2} \nabla^2_i - \sum_i \sum_{\alpha} \frac{Z_{\alpha}}{\vert \vb{r}_i - \vb{R}_{\alpha} \vert} + \frac{1}{2} \sum_{i \neq j} \frac{1}{\vert \vb{r}_i - \vb{r}_j \vert} + \frac{1}{2} \sum_{\alpha \beta} \frac{Z_{\alpha} Z_{\beta}}{R_{\alpha \beta}}
\end{align}
where:
\begin{itemize}
    \item \(\ope{T}_e\) is the kinetic energy of the electrons
    \item \(\ope{V}_{n-e}\) is the potential energy of the electrons in the field of the nuclei
    \item \(\ope{U}_{e-e}\) is the Coulomb interaction between the electrons and
    \item \(\ope{W}_{n-n}\) is the Coulomb interaction between the nuclei
\end{itemize}

The wavefunction \(\Psi (\vb{r}_1, \ldots, \vb{r}_N)\) 


\section{Density Functional Theory\label{sec:theory_dft}}

A direct solution to the electronic structure problem, this meaning obtaining the ground-state many-body wavefunction \(\Psi (\vb{r_1}, \ldots, \vb{r_N})\) for a given potential is analytically impossible even for a small number of electrons. 
As such, the need for good approximations to obtain results for real world
systems is high.
One particularly successful approach is \emph{Density Functional Theory} (DFT).

%Describing the approach of DFT comes in two parts: first, the exact reformulation of the electronic structure problem in terms of the electronic ground state
%density and second the approximation made by 

\subsection{Hohenberg-Kohn theorems}

The basis for DFT lies in the excact reformulation of the outlined electronic structure problem by Hohenberg and Kohn \cite{hohenberg_inhomogeneous_1964}.
This reformulation uses the ground state density of the electronic system as the basic variable.
[Missing]

Hohenberg-Kohn theorems:

\begin{enumerate}[I]
    \item The external potential (and by extension the ground state wave function and the ground state energy) are  unique functionals of the ground state density (except for an additive constant).
    \item The ground state energy minimizes the energy functional,
    \[E[n(r)] > E_0 \;\forall n(r) \neq n_0 (r)\].
\end{enumerate}

\subsection{Kohn-Sham equations}

One way of approximating the functional \(F[n]\) was given by Kohn and Sham \cite{kohn_self-consistent_1965}. The idea is to use a non-interacting
auxiliary system of electrons and introduce a correction potential. 

\section{Parallel computing\label{sec:parallel_computing}}

The following section will give an overview of the technical aspects of running computer code (such as \QE) on massively parallel computing environments (such as the PHYSnet compute cluster).
The information presented can be found in any textbook on parallel or high-perfomance computing \cite{hager_introduction_2010}.

\subsection{On scalabilty}

In scientific computing, one can identify two distinct reasons to distribute workloads to multiple processors:
\begin{itemize}
    \item The execution time on a single core is not sufficient. The definition of sufficient is dependent on the specific task and can range from \enquote{over lunch} to \enquote{multiple weeks}
    \item The memory requirements grow outside the capabilities of a single core
\end{itemize}
In order to judge how well a task can parallelized, usually some sort of scalabilty metric is employed, for example:
\begin{itemize}
    \item How fast can a problem be solved with \(N\) processors instead of one?
    \item What kind of bigger problem (finer resolution, more particles, etc.) can be solved with \(N\) processors?
    \item How much of the resources is used for solving the problem?
\end{itemize}
The speedup by using \(N\) workers to solve a problem instead of one is defined as \(S = \frac{T_1}{T_N}\), where \(T_1\) is the execution time on a single processor and \(T_N\) is the execution time on \(N\) processors.
In the ideal case, where all the work can be perfectly distributed among the processors, all processors need the same time for their respective workloads and don't have to wait for others processors to finish their workload to continue, the execution time on \(N\) processors would be \(\frac{T_1}{N}\), so the speedup would be \(S = \frac{T_1}{\frac{T_1}{N}} = N\).

In reality, there are many factors either limiting or in some cases supporting parallel code scalability. Limiting factors include:
\begin{itemize}
    \item \emph{Algorithmic limitations}: when parts of a calculation are mutually dependent on each other, the calculation cannot be fully parallelized
    \item \emph{Bottlenecks}: in any computer system exist resources which are shared between processor cores with limitations on parallel access. This serializes the execution by requiring cores to wait for others to complete the task which uses the shared resources in question
    \item \emph{Startup Overhead}: introducing parallelization into a programm necessarily introduces an overhead, e.g. for distributing data across all the processors
    \item \emph{Communication}: often solving a problem requires communication between different cores (e.g. exchange of interim results after a step of the calculation). Communication can be implemented very effectively, but can still introduce a big prize in computation time
\end{itemize}
On the other hand, faster parallel code execution can come from:
\begin{itemize}
    \item \emph{Better caching}: when the data the program is working with is distributed among processors (assuming constant problem size), it may enable the data to be stored in faster cache memory. Modern computers typically have three layers of cache memory, with level 1 cache being the smallest and fastest and level 3 being the largest and slowest, so smaller data chunks per processor can lead to the data not being stored in main memory, but completely in cache or in a faster cache level
\end{itemize}

\section{\QE}

\end{document}
